#!/usr/bin/env python3
from argparse import ArgumentParser
from csv import writer
from dataclasses import asdict, dataclass, fields
from datetime import datetime
from scapy.layers.inet import IP
from scapy.layers.kerberos import KRB_TGS_REQ, EncryptedData, KRB_Ticket, KRB_AP_REQ, PADATA, KRB_KDC_REQ_BODY, \
    KRB_AS_REQ
from scapy.packet import Packet
from scapy.sendrecv import sniff
from signal import signal, SIGTERM
from syslog import LOG_WARNING, syslog, LOG_INFO


@dataclass
class Record:
    time: datetime
    type: str
    source: str
    cname: str | None
    sname: str
    realm: str

rc4_hmac_signature = 23
records: list[Record]


def handle_sigterm(signum, frame):
    time = int(datetime.now().timestamp())  # количество секунд с начала эпохи (01.01.1970)
    with open(f'datasets/{time}dataset.csv', 'w') as dataset_file:
        write = writer(dataset_file)
        write.writerow([f.name for f in fields(Record)])
        record_fields = [[value for name, value in asdict(record).items()] for record in records]
        write.writerows(record_fields)
        exit(0)

def process_pack(pack: Packet):
    time = datetime.now()
    if pack.haslayer(KRB_TGS_REQ):
        req = pack[KRB_TGS_REQ]
    elif pack.haslayer(KRB_AS_REQ):
        req = pack[KRB_AS_REQ]
    else:
        syslog(LOG_WARNING, 'Обнаружен неопознанный пакет, содержащий KRB-KDC-REQ-BODY. Пропускаем')
        return
    krb_kdc_req_body = pack[KRB_KDC_REQ_BODY]
    cname = krb_kdc_req_body.cname
    cname_str = None if cname is None else '/'.join(['' if part is None else part.val.decode() for part in cname.nameString])
    sname_str = '/'.join(['' if part is None else part.val.decode() for part in krb_kdc_req_body.sname.nameString])
    source = pack[IP].src
    realm = krb_kdc_req_body.realm.val.decode()
    syslog(LOG_INFO, f'Получен {req.summary()}. Отправитель: {source} '
                     f'(клиент {cname_str}). '
                     f'Запрашиваемый сервис: {sname_str}. '
                     f'Realm: {krb_kdc_req_body.realm.val.decode()}')
    records.append(Record(time, req.summary(), source, cname_str, sname_str, realm))
    # обнаруживаем шифрование слабым алгоритмом RC4 (etype = 0x17 = 23)
    # находим алгоритм шифрования у TGT
    krb_ticket_etype = req[KRB_Ticket][EncryptedData].etype.val \
        if req.haslayer(KRB_Ticket) and req[KRB_Ticket].haslayer(EncryptedData) else None
    # находим алгоритм шифрования во вложенном AP_REQ
    krb_ap_req_etype = req[KRB_AP_REQ][EncryptedData].etype.val \
        if req.haslayer(KRB_AP_REQ) and req[KRB_AP_REQ].haslayer(EncryptedData) else None
    # находим алгоритм шифрования в PADATA
    padata_etype = req[PADATA][EncryptedData].etype.val \
        if req.haslayer(PADATA) and req[PADATA].haslayer(EncryptedData) else None
    if (krb_ticket_etype == rc4_hmac_signature or krb_ap_req_etype == rc4_hmac_signature or
            padata_etype == rc4_hmac_signature):
        syslog(LOG_WARNING, 'Обнаружен пакет, зашифрованный алгоритмом RC4.')
    # TODO обнаруживать аномальное количество TGS_REQ при помощи ML


if __name__ == '__main__':
    signal(SIGTERM, handle_sigterm)
    parser = ArgumentParser(description='Детектор атаки Kerberoasting')
    parser.add_argument('--iface', required=False, help='Отслеживаемый интерфейс')
    args = parser.parse_args()
    records = []
    iface = args.iface
    syslog(LOG_INFO, f'Детектор атаки Kerberoasting запущен.')
    syslog(LOG_INFO, f'Запущено прослушивание интерфейса {iface}.')
    sniff(lfilter=lambda pack: pack.haslayer(KRB_KDC_REQ_BODY),
          prn=lambda pack: process_pack(pack),
          iface=iface)
