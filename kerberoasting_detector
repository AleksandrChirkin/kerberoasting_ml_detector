#!/usr/bin/env python3
from argparse import ArgumentParser
from collections import OrderedDict
from csv import DictReader, writer
from dataclasses import asdict, dataclass, fields
from datetime import datetime, timedelta
from enum import Enum
from os import listdir
from os.path import isfile
from random import Random
from scapy.layers.inet import IP
from scapy.layers.kerberos import KRB_TGS_REQ, EncryptedData, KRB_Ticket, KRB_AP_REQ, PADATA, KRB_KDC_REQ_BODY, \
    KRB_AS_REQ
from scapy.packet import Packet
from scapy.sendrecv import sniff
from schedule import every, run_pending
from signal import signal, SIGTERM
from sklearn.neighbors import LocalOutlierFactor
from sklearn.svm import OneClassSVM
from syslog import LOG_WARNING, syslog, LOG_INFO
from threading import Thread
from time import perf_counter, sleep


@dataclass
class Record:
    time: datetime
    type: str
    source: str
    cname: str | None
    sname: str
    realm: str
    mark: int | None

@dataclass
class FrequenciesItem:
    number: int
    source_sname_pairs: set[tuple[str, str]]
    attack_marks: int


class LearningMechanism(Enum):
    LOF = 1
    SVM = 2

    def __str__(self):
        return self.name


rc4_hmac_signature = 23
random = Random()
lof_min = -1.1
records: list[Record]
frequencies: OrderedDict[datetime, FrequenciesItem]
running = True
mech: LearningMechanism
svm: OneClassSVM


def handle_sigterm(signum, frame):
    dump_dataset()
    global running
    running = False
    exit(0)


def run_schedule():
    while running:
        run_pending()
        sleep(1)


def dump_dataset():
    timestamp = int(datetime.now().timestamp())  # количество секунд с начала эпохи (01.01.1970)
    global records
    if len(records) > 0:
        with open(f'datasets/{timestamp}dataset.csv', 'w') as dataset_file:
            csv_writer = writer(dataset_file)
            csv_writer.writerow([f.name for f in fields(Record)])
            record_fields = [[value for name, value in asdict(record).items()] for record in records]
            csv_writer.writerows(record_fields)
        request_number = len(records)
        records = []
        syslog(LOG_INFO, f'Сделан дамп запросов в файл {timestamp}dataset.csv '
                         f'(количество запросов: {request_number})')
    else:
        syslog(LOG_INFO, f'Дамп запросов не сделан, т.к. не было запросов')


def load_datasets():
    loaded_records = []
    datasets = [f'datasets/{file}' for file in listdir('datasets') if isfile(f'datasets/{file}')]
    for dataset in datasets:
        with open(dataset) as dataset_file:
            csv_reader = DictReader(dataset_file)
            for row in csv_reader:
                record = Record(**row)
                # необходимо преобразовать в datetime, т.к. csv_reader прочитает datetime как строку
                record.time = datetime.strptime(record.time, '%Y-%m-%d %H:%M:%S.%f')
                record.mark = 0 if record.mark == '' else int(record.mark)
                loaded_records.append(record)
    freqs = OrderedDict()
    for record in loaded_records:
        time_without_seconds = record.time.replace(microsecond=0)
        if time_without_seconds in freqs.keys():
            freqs[time_without_seconds].number += 1
            freqs[time_without_seconds].source_sname_pairs.add((record.source, record.sname))
            freqs[time_without_seconds].attack_marks += record.mark
        else:
            freqs[time_without_seconds] = FrequenciesItem(1, {(record.source, record.sname)}, record.mark)
    if len(datasets) > 0:
        syslog(LOG_INFO, f'Загружено {len(loaded_records)} записей из {len(datasets)} дампов запросов')
    if mech == LearningMechanism.SVM:
        global svm
        svm = OneClassSVM()
        frequencies_vectors = [(item.number, len(item.source_sname_pairs), item.attack_marks) for item in freqs.values()]
        time_start = perf_counter()
        svm.fit_predict(frequencies_vectors)
        time_end = perf_counter()
        syslog(LOG_INFO, f'SVM создана за {time_end - time_start} секунд')
    return freqs


def find_anomaly():
    # если в течение последней секунды не зафиксировано никакой активности, то и искать аномалии бессмысленно
    time = datetime.now()
    if (time.replace(microsecond=0) - timedelta(seconds=1)) not in frequencies.keys():
        return
    frequencies_vectors = [(item.number, len(item.source_sname_pairs), item.attack_marks) for item in frequencies.values()]
    if mech == LearningMechanism.LOF:
        lof = LocalOutlierFactor(n_neighbors=20, contamination=0.1)
        time_start = perf_counter()
        lof.fit_predict(frequencies_vectors)
        lof_values = lof.negative_outlier_factor_
        time_stop = perf_counter()
        last_measurement = lof_values[-1]
        if last_measurement < lof_min:
            syslog(LOG_WARNING, f'Обнаружено аномально большое количество пакетов. '
                                f'Время анализа: {time_stop - time_start} секунд')
    elif mech == LearningMechanism.SVM:
        time_start = perf_counter()
        last_measurement = svm.decision_function([frequencies_vectors[-1]])
        time_stop = perf_counter()
        if last_measurement < 0:
            syslog(LOG_WARNING, f'Обнаружено аномально большое количество пакетов. '
                                f'Время анализа: {time_stop - time_start} скекунд')


def process_pack(pack: Packet):
    time = datetime.now()
    if pack.haslayer(KRB_TGS_REQ):
        req = pack[KRB_TGS_REQ]
    elif pack.haslayer(KRB_AS_REQ):
        req = pack[KRB_AS_REQ]
    else:
        syslog(LOG_INFO, 'Обнаружен неопознанный пакет, содержащий KRB-KDC-REQ-BODY. Пропускаем')
        return
    krb_kdc_req_body = pack[KRB_KDC_REQ_BODY]
    cname = krb_kdc_req_body.cname
    cname_str = None if cname is None else '/'.join(['' if part is None else part.val.decode() for part in cname.nameString])
    sname_str = '/'.join(['' if part is None else part.val.decode() for part in krb_kdc_req_body.sname.nameString])
    source = pack[IP].src
    realm = krb_kdc_req_body.realm.val.decode()
    syslog(LOG_INFO, f'Получен {req.summary()}. Отправитель: {source} '
                     f'(клиент {cname_str}). '
                     f'Запрашиваемый сервис: {sname_str}. '
                     f'Realm: {krb_kdc_req_body.realm.val.decode()}')
    records.append(Record(time, req.summary(), source, cname_str, sname_str, realm, None))
    time_without_seconds = time.replace(microsecond=0)
    if time_without_seconds in frequencies.keys():
        frequencies[time_without_seconds].number += 1
        frequencies[time_without_seconds].source_sname_pairs.add((source, sname_str))
    else:
        frequencies[time_without_seconds] = FrequenciesItem(1, {(source, sname_str)}, 0)
    # обнаруживаем шифрование слабым алгоритмом RC4 (etype = 0x17 = 23)
    # находим алгоритм шифрования у TGT
    krb_ticket_etype = req[KRB_Ticket][EncryptedData].etype.val \
        if req.haslayer(KRB_Ticket) and req[KRB_Ticket].haslayer(EncryptedData) else None
    # находим алгоритм шифрования во вложенном AP_REQ
    krb_ap_req_etype = req[KRB_AP_REQ][EncryptedData].etype.val \
        if req.haslayer(KRB_AP_REQ) and req[KRB_AP_REQ].haslayer(EncryptedData) else None
    # находим алгоритм шифрования в PADATA
    padata_etype = req[PADATA][EncryptedData].etype.val \
        if req.haslayer(PADATA) and req[PADATA].haslayer(EncryptedData) else None
    if (krb_ticket_etype == rc4_hmac_signature or krb_ap_req_etype == rc4_hmac_signature or
            padata_etype == rc4_hmac_signature):
        syslog(LOG_WARNING, 'Обнаружен пакет, зашифрованный алгоритмом RC4.')


if __name__ == '__main__':
    signal(SIGTERM, handle_sigterm)
    parser = ArgumentParser(description='Детектор атаки Kerberoasting')
    parser.add_argument('--iface', required=False, help='Отслеживаемый интерфейс')
    parser.add_argument('--mech', type=lambda mech: LearningMechanism[mech], default=LearningMechanism.SVM,
                        choices=list(LearningMechanism), help='Механизм обнаружения')
    args = parser.parse_args()
    records = []
    mech = args.mech
    frequencies = load_datasets()
    every().day.at('00:00').do(dump_dataset)
    every().second.do(find_anomaly)
    scheduler = Thread(target=run_schedule)
    scheduler.start()
    iface = args.iface
    syslog(LOG_INFO, f'Детектор атаки Kerberoasting запущен.')
    syslog(LOG_INFO, f'Запущено прослушивание интерфейса {iface}.')
    sniff(lfilter=lambda pack: pack.haslayer(KRB_KDC_REQ_BODY),
          prn=lambda pack: process_pack(pack),
          iface=iface)
